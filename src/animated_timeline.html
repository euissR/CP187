<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Timeline</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link rel="stylesheet" href="timeline.css", type="text/css">
</head>
<body>
    <div class="container">
        <h1 style="text-align: center; color: #333; margin-bottom: 30px;">Animated Timeline Visualization</h1>
        
        <div class="status" id="status">Loading timeline data...</div>
        
        <div class="timeline-container">
            <svg id="timeline"></svg>
        </div>
    </div>

    <script>
        let data = [];
        let currentIndex = 0;
        let animationInterval;
        let isAnimating = false;
        
        // Set up dimensions
        const margin = {top: 50, right: 200, bottom: 80, left: 200};
        const width = 1000 - margin.left - margin.right;
        const height = 600 - margin.bottom - margin.top;
        
        // Create SVG
        const svg = d3.select("#timeline")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);
            
        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // Create scales
        let yScale, colorScale, xScale;
        
        // Auto-load CSV on page load
        async function loadTimelineData() {
            try {
                const csvText = await window.fs.readFile('./data/intro_trump2.csv', { encoding: 'utf8' });
                parseCSVData(csvText);
            } catch (error) {
                console.error('Error loading CSV:', error);
                document.getElementById('status').textContent = 'Error loading CSV file. Please check if "./data/intro_trump2.csv" exists.';
            }
        }
        
        function parseCSVData(csvText) {
            try {
                // Parse CSV data
                const parsedData = d3.csvParse(csvText, d => {
                    // Try different date formats
                    let date = d3.timeParse("%Y-%m-%d")(d.date) || 
                              d3.timeParse("%m/%d/%Y")(d.date) || 
                              d3.timeParse("%d/%m/%Y")(d.date) ||
                              new Date(d.date);
                    
                    return {
                        date: date,
                        id: +d.id,
                        event: d.event,
                        type: d.type,
                        area: d.area
                    };
                });
                
                // Filter out invalid dates and sort by id
                data = parsedData
                    .filter(d => d.date && !isNaN(d.date))
                    .sort((a, b) => a.id - b.id);
                
                if (data.length === 0) {
                    document.getElementById('status').textContent = 'No valid data found. Please check your CSV format.';
                    return;
                }
                
                setupVisualization();
                document.getElementById('status').textContent = `Timeline loaded with ${data.length} events`;
                
                // Auto-start animation after a brief delay
                setTimeout(() => {
                    startAnimation();
                }, 1000);
                
            } catch (error) {
                console.error('Error parsing CSV:', error);
                document.getElementById('status').textContent = 'Error parsing CSV. Please check the file format.';
            }
        }
        
        function setupVisualization() {
            // Clear previous visualization
            g.selectAll("*").remove();
            
            // Set up scales
            const dateExtent = d3.extent(data, d => d.date);
            yScale = d3.scaleTime()
                .domain(dateExtent)
                .range([height, 0]);
            
            const types = [...new Set(data.map(d => d.type))];
            colorScale = d3.scaleOrdinal(["#309ebe", "#df3144", "#1d3956"])
                .domain(types);
            
            // Set up x scale for areas
            const areas = [...new Set(data.map(d => d.area))];
            xScale = d3.scalePoint()
                .domain(areas)
                .range([0, width])
                .padding(0.1);
            
            // Add area labels at the bottom
            g.selectAll(".area-label")
                .data(areas)
                .enter()
                .append("text")
                .attr("class", "area-label")
                .attr("x", d => xScale(d))
                .attr("y", height + 30)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("font-weight", "600")
                .style("fill", "#333")
                .text(d => d);
            
            // Add timeline axis (vertical line for each area)
            g.selectAll(".timeline-axis")
                .data(areas)
                .enter()
                .append("line")
                .attr("class", "timeline-axis")
                .attr("x1", d => xScale(d))
                .attr("x2", d => xScale(d))
                .attr("y1", 0)
                .attr("y2", height);
                
            // Add axis
            const yAxis = d3.axisLeft(yScale)
                .tickFormat(d3.timeFormat("%b %Y"));
            
            g.append("g")
                .attr("class", "y-axis")
                .call(yAxis);
        }
        
        let currentEventGroup = null;
        
        function startAnimation() {
            if (data.length === 0) return;
            
            if (isAnimating) return;
            
            isAnimating = true;
            animationInterval = setInterval(() => {
                if (currentIndex >= data.length) {
                    // Loop back to beginning
                    setTimeout(() => {
                        resetAnimation();
                        setTimeout(() => {
                            startAnimation();
                        }, 1000);
                    }, 2000); // 2 second pause before looping
                    return;
                }
                
                // Wait for previous event to fly out before showing new one
                if (currentEventGroup) {
                    setTimeout(() => {
                        addEvent(data[currentIndex]);
                        currentIndex++;
                    }, 1000); // 1 second delay after previous event starts flying out
                } else {
                    addEvent(data[currentIndex]);
                    currentIndex++;
                }
            }, 5000); // 5 seconds between each event (3s visible + 2s buffer)
        }
        
        function addEvent(d) {
            // Update y-axis scale to focus on current event with buffer
            const bufferDays = 30; // 30 days buffer on each side
            const eventDate = d.date;
            const startDate = new Date(eventDate.getTime() - bufferDays * 24 * 60 * 60 * 1000);
            const endDate = new Date(eventDate.getTime() + bufferDays * 24 * 60 * 60 * 1000);
            
            yScale.domain([endDate, startDate]); // Reversed for timeline (recent at top)
            
            // Update y-axis smoothly
            g.select(".y-axis")
                .transition()
                .duration(800)
                .call(d3.axisLeft(yScale).tickFormat(d3.timeFormat("%d %b")));
            
            const y = yScale(d.date);
            const x = xScale(d.area);
            
            // Remove previous event group reference
            currentEventGroup = null;
            
            // Create group for this event
            const eventGroup = g.append("g")
                .attr("class", "event-group")
                .attr("transform", `translate(${x}, ${height + 50})`); // Start from bottom
            
            currentEventGroup = eventGroup;
            
            // Add dot
            const dot = eventGroup.append("circle")
                .attr("class", "event-dot")
                .attr("r", 0)
                .attr("fill", colorScale(d.type))
                .attr("stroke", "white")
                .attr("stroke-width", 2);
            
            // Add event label (to the right)
            const eventLabel = eventGroup.append("text")
                .attr("class", "event-label")
                .attr("x", 15)
                .attr("y", 4)
                .attr("text-anchor", "start")
                .text(d.event)
                .style("opacity", 0);
            
            // Add date label (to the left)
            const dateLabel = eventGroup.append("text")
                .attr("class", "date-label")
                .attr("x", -15)
                .attr("y", 4)
                .attr("text-anchor", "end")
                .text(d3.timeFormat("%d %b %Y")(d.date))
                .style("opacity", 0);
            
            // Animate the event flying in
            eventGroup.transition()
                .duration(1000)
                .ease(d3.easeCubicOut)
                .attr("transform", `translate(${x}, ${y})`)
                .on("end", () => {
                    // Animate dot growth and labels appearing
                    dot.transition()
                        .duration(500)
                        .attr("r", 8);
                    
                    eventLabel.transition()
                        .duration(500)
                        .delay(200)
                        .style("opacity", 1);
                    
                    dateLabel.transition()
                        .duration(500)
                        .delay(200)
                        .style("opacity", 1);
                    
                    // After 3 seconds, start flying out to the top
                    setTimeout(() => {
                        eventGroup.transition()
                            .duration(3000)
                            .ease(d3.easeCubicIn)
                            .attr("transform", `translate(${x}, ${-100})`)
                            .style("opacity", 0)
                            .on("end", () => {
                                eventGroup.remove();
                            });
                    }, 3000); // Stay visible for 3 seconds
                });
        }
        
        function pauseAnimation() {
            isAnimating = false;
            if (animationInterval) {
                clearInterval(animationInterval);
            }
        }
        
        function resetAnimation() {
            pauseAnimation();
            currentIndex = 0;
            currentEventGroup = null;
            g.selectAll(".event-group").remove();
            
            // Reset y-scale to full range
            if (data.length > 0) {
                const dateExtent = d3.extent(data, d => d.date);
                yScale.domain(dateExtent);
                g.select(".y-axis")
                    .transition()
                    .duration(500)
                    .call(d3.axisLeft(yScale).tickFormat(d3.timeFormat("%b %Y")));
            }
        }
        
        // Load data automatically when page loads
        window.addEventListener('load', () => {
            loadTimelineData();
        });
    </script>
</body>
</html>